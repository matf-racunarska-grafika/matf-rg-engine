<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>matf-rg-engine: matf-rg-project</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">matf-rg-engine<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Base for project for the Computer Graphics course at Faculty of Mathematics, University of Belgrade</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">matf-rg-project</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> <code>matf-rg-project</code> is the base project for the Computer Graphics course at the Faculty of Mathematics, University of Belgrade for the school year of 2024/2025.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Setup</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
Linux</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
Debian based (Ubuntu, Debian...)</h3>
<p><b>To setup the necessary libraries, run:</b> <br  />
 <code>./setup.sh</code></p>
<p><b>To generate docs, run:</b> <br  />
 <code>doxygen Doxyfile</code> <br  />
 Open the documentation file in your browser: <code>docs/html/index.html</code></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Engine</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Main loop</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>App {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"><span class="keywordtype">int</span> run(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">  <span class="keywordflow">try</span> {</div>
<div class="line">    engine_setup(argc, argv);</div>
<div class="line">    app_setup();</div>
<div class="line">    initialize();</div>
<div class="line">    <span class="keywordflow">while</span> (loop()) {</div>
<div class="line">        poll_events();</div>
<div class="line">        update();</div>
<div class="line">        draw();</div>
<div class="line">    }</div>
<div class="line">    terminate();</div>
<div class="line">  } <span class="keywordflow">catch</span>(...) { ... }</div>
<div class="line">  <span class="keywordflow">return</span> on_exit();</div>
<div class="line">}</div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li><code>engine_setup</code> - here, the engine controllers are setup</li>
<li><code>app_setup</code> - the function that the user of the <code>App</code> overrides and implements a custom setup for the App</li>
<li><code>initialize</code> - <code>App</code> should gather whatever <code>Resources</code> it needs and initialize its state.</li>
<li><code>loop</code> - <code>App</code> can check whether it should continue running. If the <code>loop</code> method returns <code>false</code>, the <code>Main loop</code> stops, and the <code>App</code> terminates.</li>
<li><code>poll_events</code> - <code>App</code> collects information about the events that happened at the <code>Platform</code> and collects user input for the upcoming frame.</li>
<li><code>update</code> - <code>App</code> updates the world state, processes physics, events, and world logic, and reacts to the user inputs.</li>
<li><code>draw</code> - <code>App</code> uses <code>OpenGL</code> and draws the current state of the world.</li>
<li><code>terminate</code> - <code>App</code> terminates its state</li>
<li><code>on_exit</code> - do a final cleanup, and return an exit code</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
The App class</h2>
<p>Here is the interface of the <code>engine/core/App.hpp</code> class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>App {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">int</span> run(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv);</div>
<div class="line">        <span class="keyword">virtual</span> ~App() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        <span class="keywordtype">void</span> engine_setup(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv);</div>
<div class="line">        <span class="keywordtype">void</span> initialize();</div>
<div class="line">        <span class="keywordtype">void</span> poll_events();</div>
<div class="line">        <span class="keywordtype">bool</span> loop();</div>
<div class="line">        <span class="keywordtype">void</span> update();</div>
<div class="line">        <span class="keywordtype">void</span> draw();</div>
<div class="line">        <span class="keywordtype">void</span> terminate();</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> app_setup() { <span class="comment">// the user extends and implements setup }</span></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">int</span> on_exit() { <span class="keywordflow">return</span> 0; }</div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle_error(<span class="keyword">const</span> Error &amp;);</div>
<div class="line">    };</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Project structure</h2>
<p>Here is how the <code>Engine</code> is structured. You only need to include <code>&lt;engine/core/Engine.hpp&gt;</code> in your part of the project and all the header files will be available.</p>
<div class="fragment"><div class="line">├── core</div>
<div class="line">│   ├── App.hpp</div>
<div class="line">│   ├── Controller.hpp</div>
<div class="line">│   └── Engine.hpp</div>
<div class="line">├── graphics</div>
<div class="line">│   ├── Camera.hpp</div>
<div class="line">│   ├── GraphicsController.hpp</div>
<div class="line">│   └── OpenGL.hpp</div>
<div class="line">├── platform</div>
<div class="line">│   ├── Input.hpp</div>
<div class="line">│   ├── PlatformController.hpp</div>
<div class="line">│   ├── PlatformEventObserver.hpp</div>
<div class="line">│   └── Window.hpp</div>
<div class="line">├── resources</div>
<div class="line">│   ├── Mesh.hpp</div>
<div class="line">│   ├── Model.hpp</div>
<div class="line">│   ├── ResourcesController.hpp</div>
<div class="line">│   ├── ShaderCompiler.hpp</div>
<div class="line">│   ├── Shader.hpp</div>
<div class="line">│   ├── Skybox.hpp</div>
<div class="line">│   └── Texture.hpp</div>
<div class="line">└── util</div>
<div class="line">    ├── ArgParser.hpp</div>
<div class="line">    ├── Configuration.hpp</div>
<div class="line">    ├── Errors.hpp</div>
<div class="line">    └── Utils.hpp</div>
<div class="line">p</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
How ...</h2>
<h3><a class="anchor" id="autotoc_md9"></a>
How to set up a basic app?</h3>
<p>For a basic app setup, you need to:</p>
<ol type="1">
<li>Create a class for your App, let's call it <code>MyApp</code>, in the <code>app/src/</code>.</li>
<li>Inherit from the <code>engine::core::App</code> and implement <code>app_setup()</code>.</li>
<li>Instantiate <code>MyApp</code> object in the <code>main</code> function and call <code>run</code> on it.</li>
<li>Compile and run the program.</li>
</ol>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;engine/Engne.hpp&gt;</span></div>
<div class="line"><span class="keyword">class </span>MyApp : <span class="keyword">public</span> engine::core::App {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> setup() <span class="keyword">override</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyApp::user_setup() {</div>
<div class="line">    spdlog::info(<span class="stringliteral">&quot;Hello, setup!&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;MyApp&gt;()-&gt;run(argc, argv);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
How to add a custom controller?</h3>
<p><code>Controllers</code> are a way to hook into the engine execution. To create a custom controller:</p>
<ol type="1">
<li>Create a custom controller class that extends the <code>engine::core::Controller</code></li>
<li>Implement for the phase (<code>initialize</code>, <code>loop</code>, <code>poll_events</code>, <code>update</code>, <code>begin_draw</code>, <code>draw</code>, <code>end_draw</code>, <code>terminate</code>) for which you want to execute custom code.</li>
<li>Register the controller in the <code>MainApp::user_setup</code>.</li>
</ol>
<p>Here is the example of creating the <code>MainController</code> that enables <code>depth testing</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MainController : <span class="keyword">public</span> engine::core::Controller {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> initialize()<span class="keyword"> override </span>{</div>
<div class="line">        engine::graphics::OpenGL::enable_depth_testing();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>MainApp final : <span class="keyword">public</span> engine::core::App {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> app_setup()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keyword">auto</span> main_controller = engine::controller::register_controller&lt;MainController&gt;();</div>
<div class="line">        <span class="comment">/* Make sure that the main_controller executes after all the engine controllers. */</span></div>
<div class="line">        main_controller-&gt;after(engine::core::Controller::get&lt;engine::core::EngineControllersEnd&gt;());</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
How does the engine manage resources?</h3>
<p>Resources currently include: <code>textures</code>, <code>shaders</code>, <code>models</code>, <code>skyboxes</code>. The <code>ResourcesController</code> manages the loading, storing, and accessing the resource objects. During the <code>App::initialize</code>, the <code>ResourcesController</code> will load all the resources in the <code>resources</code> directory.</p>
<p>For every type of resource, the <code>ResourcesController</code> has a corresponding function that retrieves it:</p>
<ul>
<li><code>Model* ResourcesController::model("backpack")</code></li>
<li><code>Shader* ResourcesController::shader("basic")</code></li>
<li><code>Texture* ResourcesController::texture("awesomeface")</code></li>
<li><code>Skybox* ResourcesController::skybox("skybox")</code></li>
</ul>
<p>The argument is always the resource name without the file extension. For textures and shaders, the name is just the name of the file without the extension. For models and skyboxes, it's the name of the directory, because they have multiple files associated with them.</p>
<p>The pointer to the <code>resource</code> that the <code>ResourcesController</code> returns is a <em>non-owning pointer</em>, meaning you should <b>never call delete on it.</b> All the memory is managed internally by the <code>ResourcesController.</code></p>
<h3><a class="anchor" id="autotoc_md12"></a>
How to add a model?</h3>
<p>The <code>resources/models/</code> directory stores all the models. Let's add a backpack model from the course.</p>
<ol type="1">
<li>Create a directory, <code>resources/models/backpack.</code></li>
<li>Copy the <code>backpack</code> model files into the <code>resources/models/backpack</code>.</li>
<li>Add a configuration for your model in the config.json</li>
</ol>
<div class="fragment"><div class="line">&quot;resources&quot;: {</div>
<div class="line">   &quot;models&quot;: {</div>
<div class="line">     &quot;backpack&quot;: { # &lt;--- This will be the name of the model you use in the app</div>
<div class="line">       &quot;path&quot;: &quot;backpack/backpack.obj&quot;, # &lt;---- Relative path to the .obj file</div>
<div class="line">       &quot;flip_uvs&quot;: false # &lt;---- whether the loader should flip the texture coordinates</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line"> }</div>
</div><!-- fragment --><ol type="1">
<li>The <code>ResourcesController</code> will automatically load this model during <code>ResourcesController::initialize()</code>; you should see a log:</li>
</ol>
<div class="fragment"><div class="line">...</div>
<div class="line">[2024-12-08 11:19:12.347] [info] load_model(backpack, resources/models/backpack/backpack.obj)</div>
<div class="line">[2024-12-08 11:19:13.272] [info] Loading texture: resources/models/backpack/diffuse.jpg</div>
<div class="line">[2024-12-08 11:19:14.114] [info] Loading texture: resources/models/backpack/specular.jpg</div>
<div class="line">[2024-12-08 11:19:14.479] [info] Loading texture: resources/models/backpack/normal.png</div>
<div class="line">...</div>
</div><!-- fragment --><ol type="1">
<li>Use the model in your App:</li>
</ol>
<div class="fragment"><div class="line">Model* backpack = engine::core::Controller::get&lt;engine::resources::ResourcesController&gt;()-&gt;model(<span class="stringliteral">&quot;backpack&quot;</span>);</div>
<div class="line">Shader* shader   = ... </div>
<div class="line">backpack-&gt;draw(shader);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md13"></a>
How to add a texture?</h3>
<ol type="1">
<li>Add a texture file <code>awesomeface.png</code> to the <code>resources/textures</code> directory</li>
<li>Use it in the App (<code>ResourcesController</code> will automatically load it)</li>
</ol>
<div class="fragment"><div class="line">Texture* texture = engine::core::Controller::get&lt;ResourcesController&gt;()-&gt;texture(<span class="stringliteral">&quot;awesomeface&quot;</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
How to add a shader?</h3>
<ol type="1">
<li>Create a <code>your_shader.glsl</code> in the <code>resources/shaders/your_shader.glsl</code>.</li>
<li>Implement <code>vertex</code>, <code>fragment</code>, and <code>geometry</code> (optional), shaders in the same file.</li>
<li>Use it in the App:</li>
</ol>
<div class="fragment"><div class="line">Shader* shader = engine::core::Controller::get&lt;ResourcesController&gt;()-&gt;shader(<span class="stringliteral">&quot;your_shader&quot;</span>);</div>
<div class="line">Model* backpack = ...;</div>
<div class="line">backpack-&gt;draw(shader);</div>
</div><!-- fragment --><p>Vertex, fragment, and geometry shaders are written in the same file. Use the <code>// #shader vertex|fragment|geometry</code> to declare the start of the shader. Here is an example:</p>
<div class="fragment"><div class="line">//#shader vertex</div>
<div class="line">#version 330 core</div>
<div class="line">layout (location = 0) in vec3 aPos;</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    gl_Position = vec4(aPos, 1.0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//#shader fragment</div>
<div class="line">#version 330 core</div>
<div class="line"> </div>
<div class="line">out vec4 FragColor;</div>
<div class="line"> </div>
<div class="line">void main() {</div>
<div class="line">    FragColor = vec4(0.0, 0.0, 0.0, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>ResourcesController</code> will load and compile all the shaders in the <code>resources/shaders</code> directory.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
How to draw a GUI?</h3>
<p><code>Engine</code> uses the <a href="https://github.com/ocornut/imgui">imgui</a> library to draw a GUI. See the library page for more examples. For GUI to be visible it should be drawn last, after all the world objects. Here is an example of displaying camera info in a GUI.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> graphics = engine::core::Controller::get&lt;engine::graphics::GraphicsController&gt;();</div>
<div class="line">graphics-&gt;begin_gui();</div>
<div class="line"><span class="comment">// Draw Camera Info window</span></div>
<div class="line">{</div>
<div class="line">    ImGui::Begin(<span class="stringliteral">&quot;Camera info&quot;</span>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;c = *camera;</div>
<div class="line">    ImGui::Text(<span class="stringliteral">&quot;Camera position: (%f, %f, %f)&quot;</span>, c.Position.x, c.Position.y, c.Position.z);</div>
<div class="line">    ImGui::Text(<span class="stringliteral">&quot;(Yaw, Pitch): (%f, %f)&quot;</span>, c.Yaw, c.Pitch);</div>
<div class="line">    ImGui::Text(<span class="stringliteral">&quot;Camera front: (%f, %f, %f)&quot;</span>, c.Front.x, c.Front.y, c.Front.z);</div>
<div class="line">    ImGui::End();</div>
<div class="line">}</div>
<div class="line">graphics-&gt;end_gui();</div>
</div><!-- fragment --><p><img src="../../extra/img.png" alt="img.png" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md16"></a>
How to throw and handle errors?</h3>
<p>The <code>Engine</code> defines a base <code>Error</code> type with two subclasses, <code>EngineError</code> and <code>UserError</code>. They serve as a <em>graceful</em> way to terminate the application and provide the user with some helpful information on how to <b>fix</b> the error.</p>
<p>For example, the <code>ResourcesController</code> will throw <code>AssetLoadingError</code> if it can't read the asset file.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) {</div>
<div class="line">    <span class="keywordflow">throw</span> util::EngineError(util::EngineError::Type::AssetLoadingError,</div>
<div class="line">                            std::format(<span class="stringliteral">&quot;Assimp error while reading model: {} from path {}.&quot;</span>,</div>
<div class="line">                                        model_path.string(), name));</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>Exceptions</code> shouldn't be used as a control-flow mechanism, instead they should be used to inform the user of an <code>exceptional</code> event that the program can't do anything about, like the missing asset file.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
How to get the key/mouse press event?</h3>
<p>The <code>PlatformController</code> differentiates between four types of button/key states:</p>
<ol type="1">
<li><code>engine::platform::Key::State::JustPressed</code> -&gt; Only in the first frame when the button was registered as pressed</li>
<li><code>engine::platform::Key::State::Pressed</code> -&gt; Every subsequent frame if the button is still held</li>
<li><code>engine::platform::Key::State::JustReleased</code> -&gt; Just the first frame in which the button was registered as released</li>
<li><code>engine::platform::Key::State::Released</code> -&gt; Button is not pressed</li>
</ol>
<p>Use the <code>PlatformController::key</code> method to get the state of the key in a given frame:</p>
<p>Here is an example of turning GUI on/off drawing using the <code>F2</code> key:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> poll_events()<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> platform = engine::core::Controller::get&lt;engine::platform::PlatformController&gt;();</div>
<div class="line">    <span class="keywordflow">if</span> (platform-&gt;key(engine::platform::KeyId::KEY_F2).state() == engine::platform::Key::State::JustPressed) {</div>
<div class="line">        m_draw_gui = !m_draw_gui;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Keys have a unique identifier: via <code>engine::platform::KeyId</code>.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
How to register a callback for platform events?</h3>
<ol type="1">
<li>Implement the event observer by extending the class <code>engine::platform::PlatformEventObserver</code>, and override methods you'd like to have a custom operation executed once the event happens</li>
<li>Register the <code>observer</code> instance in the <code>PlatformController</code>.</li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">class </span>MainPlatformEventObserver final : <span class="keyword">public</span> engine::platform::PlatformEventObserver {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> on_keyboard(engine::platform::Key key)<span class="keyword"> override </span>{</div>
<div class="line">        spdlog::info(<span class="stringliteral">&quot;Keyboard event: key={}, state={}&quot;</span>, key.name(), key.state_str());</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>MainController : <span class="keyword">public</span> engine::core::Controller {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">void</span> initialize()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// ... </span></div>
<div class="line">        <span class="keyword">auto</span> observer = std::make_unique&lt;MainPlatformEventObserver&gt;();</div>
<div class="line">        engine::core::Controller::get&lt;engine::platform::PlatformController&gt;()-&gt;register_platform_event_observer(std::move(observer));</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, for every keyboard event, the <code>PlatformController</code> will call <code>MainPlatformEventObserver::on_keyboard</code> and pass the <code>key</code> on which the event occurred as an argument.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
How to get Window properties?</h3>
<p><code>PlatformController</code> initializes and stores the <code>Window</code> handle, which you can access via:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> platform = engine::core::Controller::get&lt;engine::platform::PlatformController&gt;();</div>
<div class="line">platform-&gt;window()-&gt;height()</div>
<div class="line">platform-&gt;window()-&gt;width()</div>
<div class="line">platform-&gt;window()-&gt;title()</div>
</div><!-- fragment --><p>Also, the <code>PlatformController</code> will update the window properties if the size of the window changes.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
How to add new OpenGL calls?</h3>
<p>Rendering actions that require more than one OpenGL call should be abstracted in the <code>engine::graphics::OpenGL</code> class. For example, <code>OpenGL::compile_shaer</code> compiles a GLSL shader and returns the shader_id.</p>
<div class="fragment"><div class="line">uint32_t OpenGL::compile_shader(<span class="keyword">const</span> std::string &amp;shader_source,</div>
<div class="line">                                resources::ShaderType shader_type) {</div>
<div class="line">    uint32_t shader_id             = CHECKED_GL_CALL(glCreateShader, shader_type_to_opengl_type(shader_type));</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *shader_source_cstr = shader_source.c_str();</div>
<div class="line">    CHECKED_GL_CALL(glShaderSource, shader_id, 1, &amp;shader_source_cstr, <span class="keyword">nullptr</span>);</div>
<div class="line">    CHECKED_GL_CALL(glCompileShader, shader_id);</div>
<div class="line">    <span class="keywordflow">return</span> shader_id;</div>
<div class="line">}</div>
</div><!-- fragment --><p>If the OpenGL call fails, the <code>CHECKED_GL_CALL</code> macro throws an <code>OpenGLError</code> in DEBUG mode. The engine will print the error description of and the source location in which it occurred.</p>
<p>Why this way? It's less error-prone and more straightforward to add debugging assertions and error checks if needed.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
How do you add a configuration option?</h3>
<p>You can configure some parts of the <code>engine</code> in the <code>config.json</code>. For example, we can configure the size and the title of the window when the application starts.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;window&quot;: {</div>
<div class="line">    &quot;height&quot;: 600,</div>
<div class="line">    &quot;title&quot;: &quot;Hello, window!&quot;,</div>
<div class="line">    &quot;width&quot;: 800</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can also add your custom configuration options:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;exposure&quot;: 2.45,</div>
<div class="line">  &quot;on_exit_message&quot;: &quot;Bye...&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>and use them:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> &amp;config = util::Configuration::config();</div>
<div class="line"><span class="keywordtype">float</span> exposure = config[<span class="stringliteral">&quot;exposure&quot;</span>].get&lt;<span class="keywordtype">float</span>&gt;();</div>
<div class="line">std::string gamma = config[<span class="stringliteral">&quot;on_exit_message&quot;</span>].get&lt;std::string&gt;();</div>
</div><!-- fragment --><p>The <code>Configuration</code> class uses <a href="https://github.com/nlohmann/json">nlohmann/json</a> library to load and store <code>json</code> files, see the library page for documentation.</p>
<h3><a class="anchor" id="autotoc_md22"></a>
How to pass a command line argument?</h3>
<p>You use the <code>ArgParser</code> to parse the command line arguments anywhere from the program. For example, for the invocation command: <code>./matf-rg-engine ... --fps 120</code>, the <code>parser-&gt;arg("--fps")</code> will return the value 60. If the argument is not present, it will return the default value passed as the second argument to the <code>arg</code> method.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup()<span class="keyword"> override </span>{</div>
<div class="line">    <span class="keyword">auto</span> parser = engine::util::ArgParser()-&gt;instance();</div>
<div class="line">    <span class="keyword">auto</span> fps = parser-&gt;arg&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;--fps&quot;</span>, 60);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md23"></a>
Tutorials</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
App test tutorial</h2>
<p>Here you can find a walkthrough tutorial for recreating the <code>engine/test/app</code> that demonstrates how to use different engine systems. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
